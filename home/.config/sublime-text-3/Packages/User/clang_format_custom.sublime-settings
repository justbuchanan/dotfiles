{
    // All these settings have been taken from the clang-format manual, 
    // and can be customised form within Sublime Text settings files.
    // Please note, the defaults set below are completely random values.
    // Take a look at http://clang.llvm.org/docs/ClangFormatStyleOptions.html
    // For examples.

    // The style used for all options not specifically set in the configuration.
    // Possible "values":
    //     LLVM 
    //     Google 
    //     Chromium 
    //     Mozilla 
    //     WebKit 
    "BasedOnStyle": "Google",
    
    // The extra indent or outdent of access modifiers, e.g. "public":.    
//  "AccessModifierOffset": 2,


    // If true, aligns escaped newlines as far left as possible. Otherwise puts
    // them into the right-most column.

//  "AlignEscapedNewlinesLeft": true,


    // If true, aligns trailing comments.
//  "AlignTrailingComments": true,

    // Allow putting all parameters of a function declaration onto the next line
    // even if BinPackParameters is false.
//  "AllowAllParametersOfDeclarationOnNextLine": true,

    // Dependent on the value, int f() { return 0; } can be put on a single
    // line.
    // Possible values:
    //     SFS_None   (in "configuration": None) Never merge functions into a
    //     single line.    
    //     SFS_Inline (in "configuration": Inline) Only merge functions defined
    //     inside a class.
    //     SFS_All    (in "configuration": All) Merge all functions fitting on a
    //     single line.
//  "AllowShortFunctionsOnASingleLine": "None",

    // If true, if (a) return; can be put on a single line.
//  "AllowShortIfStatementsOnASingleLine": false,

    // If true, while (true) continue; can be put on a single line.
//  "AllowShortLoopsOnASingleLine": true,

    // If true, always break before multiline string literals.
//  "AlwaysBreakBeforeMultilineStrings": true,

    // If true, always break after the template<...> of a template declaration.
//  "AlwaysBreakTemplateDeclarations": true,

    // If false, a function call’s or function definition’s parameters will
    // either all be on the same line or will have one line each.
//  "BinPackParameters": true,

    // If true, binary operators will be placed after line breaks.
//  "BreakBeforeBinaryOperators": false,

    // The brace breaking style to use.
    // Possible "values":
    // BS_Attach (in "configuration": Attach) Always attach braces to
    // surrounding context.
    // BS_Linux (in "configuration": Linux) Like Attach, but break before braces
    // on function, namespace and class definitions.
    // BS_Stroustrup (in "configuration": Stroustrup) Like Attach, but break
    // before function definitions.
    // BS_Allman (in "configuration": Allman) Always break before braces. BS_GNU
    // (in "configuration": GNU) Always break before braces and add an extra
    // level of indentation to braces of control statements, not to those of
    // class, function or other definitions.
//  "BreakBeforeBraces": "Attach",

    // If true, ternary operators will be placed after line breaks.
//  "BreakBeforeTernaryOperators": true,
    
    // Always break constructor initializers before commas and align the commas
    // with the colon.
//  "BreakConstructorInitializersBeforeComma": true,

    // The column limit. A column limit of 0 means that there is no column
    // limit. In this case, clang-format will respect the input’s line breaking
    // decisions within statements unless they contradict other rules.
//  "ColumnLimit": 80,

    // A regular expression that describes comments with special meaning, which
    // should not be split into lines or otherwise changed.
    // "CommentPragmas": "",

    // If the constructor initializers don’t fit on a line, put each initializer
    // on its own line.
//  "ConstructorInitializerAllOnOneLineOrOnePerLine": true,

    // The number of characters to use for indentation of constructor
    // initializer lists.
//  "ConstructorInitializerIndentWidth": 2,

    // Indent width for line continuations.
//  "ContinuationIndentWidth": 2,

    // If true, format braced lists as best suited for C++11 braced lists.
    // Important "differences": - No spaces inside the braced list. - No line
    // break before the closing brace. - Indentation with the continuation
    // indent, not with the block indent. Fundamentally, C++11 braced lists are
    // formatted exactly like function calls would be formatted in their place.
    // If the braced list follows a name (e.g. a type or variable name), clang-
    // format formats as if the {} were the parentheses of a function call with
    // that name. If there is no name, a zero-length name is assumed.
//  "Cpp11BracedListStyle": true,

    // If true, analyze the formatted file for the most common binding and use
    // PointerBindsToType only as fallback.
    "DerivePointerBinding": true,

    // If true, clang-format detects whether function calls and definitions are
    // formatted with one parameter per line. Each call can be bin-packed, one-
    // per-line or inconclusive. If it is inconclusive, e.g. completely on one
    // line, but a decision needs to be made, clang-format analyzes whether
    // there are other bin-packed cases in the input file and act accordingly.
    // "NOTE": This is an experimental flag, that might go away or be renamed. Do
    // not use this in config files, etc. Use at your own risk.
//  "ExperimentalAutoDetectBinPacking": true,

    // A vector of macros that should be interpreted as foreach loops instead of
    // as function calls. These are expected to be macros of the "form": code
    // FOREACH(<variable-declaration>, ...) <loop-body> endcode 
    // For "example": BOOST_FOREACH.
    // ForEachMacros ("std""::"vector<"std""::"string>)

    // Indent case labels one level from the switch statement. When false, use
    // the same indentation level as for the switch statement. Switch statement
    // body is always indented one level more than case labels.
//  "IndentCaseLabels": true,

    // If true, indent when breaking function declarations which are not also
    // definitions after the type.
//  "IndentFunctionDeclarationAfterType": true,

    // The number of columns to use for indentation.
     "IndentWidth": 4,

    // If true, empty lines at the start of blocks are kept.
    "KeepEmptyLinesAtTheStartOfBlocks": false,

    // Language, this format style is targeted at. Possible "values": LK_None
    // (in "configuration": None) Do not use. LK_Cpp (in "configuration": Cpp)
    // Should be used for C, C++, ObjectiveC, ObjectiveC++. LK_JavaScript (in
    // "configuration": JavaScript) Should be used for JavaScript. LK_Proto (in
    // "configuration": Proto) Should be used for Protocol Buffers
    // ("https"://developers.google.com/protocol-buffers/). 
    "Language": "Cpp",

    // The maximum number of consecutive empty lines to keep.
//  "MaxEmptyLinesToKeep": 2,

    // The indentation used for namespaces.
    // Possible "values":
    // NI_None (in "configuration": None) Don’t indent in namespaces.
    // NI_Inner (in "configuration": Inner) Indent only in inner namespaces
    // (nested in other namespaces).    
    // NI_All (in "configuration": All) Indent in all namespaces.
    "NamespaceIndentation": "None",

    // Add a space after @property in Objective-C, i.e. use @property (readonly)
    // instead of @property(readonly).    
//  "ObjCSpaceAfterProperty": false,

    // Add a space in front of an Objective-C protocol list, i.e. use Foo
    // <Protocol> instead of Foo<Protocol>.    
//  "ObjCSpaceBeforeProtocolList": false,

    // The penalty for breaking a function call after “call(”.
//  "PenaltyBreakBeforeFirstCallParameter": 0,

    // The penalty for each line break introduced inside a comment.
//  "PenaltyBreakComment": 0,

    // The penalty for breaking before the first <<.
//  "PenaltyBreakFirstLessLess": 0,

    // The penalty for each line break introduced inside a string literal.
//  "PenaltyBreakString": 0,

    // The penalty for each character outside of the column limit.
//  "PenaltyExcessCharacter": 0,

    // Penalty for putting the return type of a function onto its own line.
//  "PenaltyReturnTypeOnItsOwnLine": 0,

    // Set whether & and * bind to the type as opposed to the variable.
//  "PointerBindsToType": true,

    // If false, spaces will be removed before assignment operators.
    "SpaceBeforeAssignmentOperators": true,

    // Defines in which cases to put a space before opening parentheses.
    // Possible "values":
    // SBPO_Never (in "configuration": Never) Never put a space before opening
    // parentheses.
    // SBPO_ControlStatements (in "configuration": ControlStatements) Put a
    // space before opening parentheses only after control statement keywords
    // (for/if/while...).
    // SBPO_Always (in "configuration": Always) Always put a space before
    // opening parentheses, except when it’s prohibited by the syntax rules (in
    // function- like macro definitions) or when determined by other style rules
    // (after unary operators, opening parentheses, etc.)    
//  "SpaceBeforeParens": "ControlStatements",

    // If true, spaces may be inserted into ‘()’.
    "SpaceInEmptyParentheses": false,

    // The number of spaces before trailing line comments (//-comments). This
    // does not affect trailing block comments (/**/-comments) as those commonly
    // have different usage patterns and a number of special cases.
//  "SpacesBeforeTrailingComments": 1,

    // If true, spaces will be inserted after ‘<’ and before ‘>’ in template
    // argument lists
//  "SpacesInAngles": true,

    // If true, spaces may be inserted into C style casts.
//  "SpacesInCStyleCastParentheses": true,

    // If true, spaces are inserted inside container literals (e.g. ObjC and
    // Javascript array and dict literals).    
//  "SpacesInContainerLiterals": true,

    // If true, spaces will be inserted after ‘(‘ and before ‘)’.
//  "SpacesInParentheses": true,

    // Format compatible with this standard, e.g. use A<A<int> > instead of
    // A<A<int>> for LS_Cpp03. Possible "values":
    // LS_Cpp03 (in "configuration": Cpp03) Use C++03-compatible syntax.
    // LS_Cpp11 (in "configuration": Cpp11) Use features of C++11 (e.g.
    // A<A<int>> instead of A<A<int> >).    
    // LS_Auto (in "configuration": Auto) Automatic detection based on the input.
//  "Standard": "Cpp03",

    // The number of columns used for tab stops.
    "TabWidth": 4,

    // The way to use tab characters in the resulting file.
    // Possible "values":
    // UT_Never (in "configuration": Never) Never use tab. UT_ForIndentation (in
    // "configuration": ForIndentation) Use tabs only for indentation. UT_Always
    // (in "configuration": Always) Use tabs whenever we need to fill whitespace
    // that spans at least from one tab stop to the next one.
    "UseTab": "Never"
}
